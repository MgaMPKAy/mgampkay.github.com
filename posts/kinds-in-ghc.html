<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>MgaMPKAy's Everything about kinds (in GHC)</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
  </head>
  <body>
    <header id="header">
      <div id="logo">
        <a href="../">MgaMPKAy's Blog</a>
      </div>
      <nav id="navigation">
        <a href="../">Home</a>
        <a href="../about.html">About</a>
        <a href="../archive.html">Archive</a>
      </nav>
    </header>

    <div id="content">
      <h1>Everything about kinds (in GHC)</h1>

      <article>
  <div class="info">November 24, 2013</div>

  <section id="article-content">
    <p>值（value）可以通过类型（type）进行分类，那么什么对类型进行分类呢？那就是 Kind！</p>
<pre><code>      Kind
   ----------
      Type
   ----------
      Value</code></pre>
<h1 id="基础">基础</h1>
<p>Kind的基本文法：</p>
<pre><code>k ::= *
      | k -&gt; k</code></pre>
<p>这个定义说一个kind可以是<code>*</code>，或者通过<code>-&gt;</code>和两个kind构造出一个新的kind。例子：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Int</span><span class="ot">    ::</span> <span class="fu">*</span>
<span class="dt">Bool</span><span class="ot">   ::</span> <span class="fu">*</span>
<span class="dt">Maybe</span><span class="ot">  ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>
<span class="dt">Either</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre>
<p><code>*</code>表示一个值的类型的kind，<code>-&gt;</code>就像函数类型，可以用来表示类型构造子的kind。</p>
<p>Kind描述了类型和类型构造子的结构，规范他们的组合：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Maybe</span> <span class="dt">Bool</span><span class="ot"> ::</span> <span class="fu">*</span> <span class="co">-- ok</span>
<span class="dt">Maybe</span> <span class="dt">Either</span>    <span class="co">-- kind mismatch</span>

<span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Maybe</span>  <span class="co">-- ok</span>
<span class="kw">instance</span> <span class="kw">Functor</span> <span class="dt">Either</span> <span class="co">-- kind mismatch</span></code></pre>
<h1 id="kind-polymorphism">Kind polymorphism</h1>
<p>我们看一下几个Typeable：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Typeable</span> (<span class="ot">t ::</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    typeOf ::</span> t <span class="ot">-&gt;</span> <span class="dt">TypeRep</span>

<span class="kw">class</span> <span class="dt">Typeable1</span> (<span class="ot">t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    typeOf1 ::</span> t a <span class="ot">-&gt;</span> <span class="dt">TypeRep</span>

<span class="kw">class</span> <span class="dt">Typeable2</span> (<span class="ot">t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="kw">where</span>
<span class="ot">    typeOf2 ::</span> t a b <span class="ot">-&gt;</span> <span class="dt">TypeRep</span></code></pre>
<p><code>Typeable</code>的作用是为每一个类型（kind为<code>*</code>）定义一个<code>TypeRep</code>，用做运行时的类型信息。类似的，<code>Typeable1</code>和<code>Typeable2</code>的实例可以为kind为<code>* -&gt; *</code>和 <code>* -&gt; * -&gt; *</code>的类型构造子提供类型信息。<code>typeOfN</code>的第一个参数都是没用的，因为我们只需要类型信息，不需要值。</p>
<p>要定义这么多（一直到7）相似的type class的原因是没有多态的kind，每一个type class需要的kind都是固定的。如果能像参数化多态一样，有个kind参数来表示kind多态就好了，于是就有了 <code>PolyKinds</code>扩展。</p>
<p>有了多态的kind之后，Typeable就可以这样定义：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE PolyKinds #-}</span>           <span class="co">-- for Proxy, Typeable</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span> <span class="co">-- for typeOf, typeOf1 ...</span>

<span class="kw">data</span> <span class="dt">Proxy</span> t <span class="fu">=</span> <span class="dt">Proxy</span>

<span class="kw">class</span> <span class="dt">Typeable</span> t <span class="kw">where</span>
<span class="ot">  typeOf ::</span> <span class="dt">Proxy</span> t <span class="ot">-&gt;</span> <span class="dt">TypeRep</span>

<span class="ot">typeOf ::</span> forall a<span class="fu">.</span> <span class="dt">Typeable</span> a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">String</span>
typeOf _ <span class="fu">=</span> typeRep (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a)

<span class="ot">typeOf1 ::</span> forall a (<span class="ot">t ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="fu">.</span> <span class="dt">Typeable</span> t <span class="ot">=&gt;</span> t a <span class="ot">-&gt;</span> <span class="dt">String</span>
typeOf1 _ <span class="fu">=</span> typeRep (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> t)</code></pre>
<p>开启<code>PolyKinds</code>之后，GHC把<code>Proxy</code>的kind推导为<code>k -&gt; *</code>，Typeable的kind为<code>k -&gt;  Constraint</code>，这里的k就像是类型参数一样，是个kind参数。</p>
<p>直接这样定义是不行的：</p>
<pre><code>class Typeable t where
    typeRep :: t -&gt; String</code></pre>
<p>因为<code>typeRep</code>是个函数，参数的king必须是<code>*</code>，那么<code>t</code>的kind就固定成<code>*</code>了，所以通过一个<code>Proxy :: k -&gt; *</code>，我们就能让<code>typeRep :: Proxy t -&gt; String</code>的参数的kind为<code>*</code>，而<code>t</code>的kind是任意的。</p>
<p><code>Proxy</code>的作用就是携带类型信息，不需要值，所以像下面这样定义<code>Proxy</code>是可以的，不过要到处用<code>undefined</code>，反而不好：</p>
<pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Proxy</span><span class="ot"> ::</span> k <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre>
<h1 id="constraint-kinds">Constraint Kinds</h1>
<h1 id="datatype-promotion">Datatype promotion</h1>
  </section>

  <section id="comment">
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </section>

</article>

<script type="text/javascript" src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
<script type="text/javascript" src="../js/post.js"></script>


    </div>
    <footer id="footer">
      @mgampkay
    </footer>

    <script type="text/javascript" src="../js/ga.js"></script>

  </body>
</html>
